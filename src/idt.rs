use core::mem::size_of;

/// Saved state passed to a rust interrupt handler.
#[repr(C,packed)]
#[derive(Debug)]
pub struct IsrSave {
	r11: u64,
	r10: u64,
	r9: u64,
	r8: u64,
	rcx: u64,
	rdx: u64,
	rsi: u64,
	rdi: u64,
	rax: u64,
    int_no: u64,
    err_code: u64,
    rip: u64,
    cs: u64,
    rflags: u64,
    rsp: u64,
    ss: u64,
}

#[repr(C,packed)]
#[derive(Clone, Copy)]
struct Gate {
    offset_lo: u16,
    segment: u16,
    ist: u8, // Only the bottom 3 bits are significant; rest must be zero.
    type_dpl_p: u8, // three fields on one byte, of sizes 4, 2, and 2 bits
                    // respectively. There is a zero bit before the dpl.
    offset_mid: u16,
    offset_hi: u32,
    reserved: u32,
}

#[repr(C,packed)]
struct IDTPtr {
    limit: u16,
    offset: *const [Gate; NUM_IDT_ENTS],
}

const NUM_IDT_ENTS: usize = 256;
const ZERO_GATE: Gate = Gate{
    offset_lo: 0,
    segment: 0,
    ist: 0,
    type_dpl_p: 0,
    offset_mid: 0,
    offset_hi: 0,
    reserved: 0,
};

static mut BOOT_IDT: [Gate; NUM_IDT_ENTS] = [ZERO_GATE; NUM_IDT_ENTS];

static mut IDT_PTR: IDTPtr = IDTPtr{
    limit: 0,
    offset: 0 as *const [Gate; NUM_IDT_ENTS],
};

static mut INT_HANDLERS: [fn(&mut IsrSave) -> (); NUM_IDT_ENTS] =
    [no_int_handler; NUM_IDT_ENTS];

impl Gate {

    /// Create a new interrupt gate.
    ///
    /// `handler` is the interrupt handler. Note that these to *not* follow
    /// the same calling convention as rust and/or C -- they must be defined
    /// in assembly. See `isr.s` and `make_isrs.sh`. TODO: we should probably
    /// put some other type there.
    ///
    /// the other fields correspond to what is documented in the intel manual.
    ///
    /// Note that "type" is always that of a 64-bit interrupt gate.
    pub fn new(
        handler: unsafe extern fn() -> (),
        segment: u16,
        present : bool,
        _ist : u8, // Interrupt stack table. 3 bits
        dpl : u8, // Discriptor priviledge level. 2 bits.
    ) -> Self {
        let mut ret = ZERO_GATE;
        ret.set_offset(handler as u64);
        ret.set_segment(segment);
        ret.set_present(present);
        ret.set_dpl(dpl);

        ret.set_type(0b1110); // [intel/3/3.5] (table 3-2).
        return ret;
    }

    pub fn set_offset(&mut self, offset: u64) {
        self.offset_lo  = ((offset >> 0 ) & 0xffff    ) as u16;
        self.offset_mid = ((offset >> 16) & 0xffff    ) as u16;
        self.offset_hi  = ((offset >> 32) & 0xffffffff) as u32;
    }

    pub fn set_present(&mut self, present: bool) {
        let present_bit = if present { 1 } else { 0 };
        self.type_dpl_p &= !(1 << 7);
        self.type_dpl_p |= present_bit << 7;
    }

    pub fn set_dpl(&mut self, dpl: u8) {
        if dpl > 3 {
            panic!("DPL out of range");
        }
        self.type_dpl_p &= !(3 << 5);
        self.type_dpl_p |= dpl << 5;
    }

    fn set_type(&mut self, typ: u8) {
        if typ > 0xf {
            panic!("descriptor type is too large (max 4 bits)");
        }
        self.type_dpl_p &= 0xf0;
        self.type_dpl_p |= typ;
    }

    pub fn set_segment(&mut self, segment: u16) {
        self.segment = segment;
    }
}


/// This declares isr0-255 (defined in assembly) and a function `init_boot_idt`
/// to install them in BOOT_IDT. It is generated by build.rs.
mod gen {
    include!(concat!(env!("OUT_DIR"), "/idt_gen.rs"));
}

fn no_int_handler(state: &mut IsrSave) {
    panic!("No interrupt handler for interrupt #{}!\n\
            Interrupt state: {:?}\n", state.int_no, state);
}

/// This is the rust entry point for our interrupt handlers; it is invoked
/// by the assembly routines we place in the IDT.
#[no_mangle]
pub unsafe extern fn int_handler_main(state: &mut IsrSave) {
    INT_HANDLERS[state.int_no as usize](state)
}

unsafe fn lidt(idtptr: &IDTPtr) {
    asm!("lidt (%rax)" :: "{rax}"(idtptr) :: "volatile");
}

fn int_handler_noop(_state: &mut IsrSave) {}

pub unsafe fn init() {
    INT_HANDLERS[7] = int_handler_noop;

    IDT_PTR = IDTPtr{
        limit: (NUM_IDT_ENTS * size_of::<Gate>() - 1) as u16,
        offset: &BOOT_IDT as *const [Gate; NUM_IDT_ENTS],
    };

    gen::init_boot_idt();
    lidt(&IDT_PTR);
}
